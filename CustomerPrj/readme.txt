

注意生成的测试样本samples.txt没在代码里
做数据合法性的处理
需手动删掉负数ID或者重复的



C#没有像C++一样的作用域限定符::
所以自定义命名空间或者全局函数/变量通通大写

C++的容器是通过基于placement new的内存分配器来管理、装东西的
即便如此，在语义上也最好是按值存储而不是存放指针
C++17加入了std::pmr::synchronized_pool_resource

C#中的collection内存管理机制未知，存储class而非struct会否有内存碎片的问题不得而知
大量存储struct会否要操心stackoverflow而去调整编译器的设置就不得而知了


CLR机制和操作系统会很智能地为我们选择是否需要开辟新的线程来做异步操作


数据结构的选用，时间复杂度、线程安全容器（集合）.....



对于需求2和需求3而言，处理非法输入不论是用断言assert还是异常exception
都对用户不友好或者对前端开发人员不友好，以ActionResult返回更合适

